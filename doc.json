
======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/access/Ownable.sol:Ownable =======
Developer Documentation
{
    "details": "Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",
    "kind": "dev",
    "methods": {
        "constructor": {
            "details": "Initializes the contract setting the deployer as the initial owner."
        },
        "owner()": {
            "details": "Returns the address of the current owner."
        },
        "renounceOwnership()": {
            "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
        },
        "transferOwnership(address)": {
            "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol:ReentrancyGuard =======
Developer Documentation
{
    "details": "Contract module that helps prevent reentrant calls to a function. Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them. TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].",
    "kind": "dev",
    "methods": {},
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol:ERC1155 =======
Developer Documentation
{
    "details": "Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 Originally based on code by Enjin: https://github.com/enjin/erc-1155 _Available since v3.1._",
    "events": {
        "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."
        },
        "TransferBatch(address,address,address,uint256[],uint256[])": {
            "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
        },
        "TransferSingle(address,address,address,uint256,uint256)": {
            "details": "Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."
        },
        "URI(string,uint256)": {
            "details": "Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."
        }
    },
    "kind": "dev",
    "methods": {
        "balanceOf(address,uint256)": {
            "details": "See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address."
        },
        "balanceOfBatch(address[],uint256[])": {
            "details": "See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length."
        },
        "constructor": {
            "details": "See {_setURI}."
        },
        "isApprovedForAll(address,address)": {
            "details": "See {IERC1155-isApprovedForAll}."
        },
        "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": {
            "details": "See {IERC1155-safeBatchTransferFrom}."
        },
        "safeTransferFrom(address,address,uint256,uint256,bytes)": {
            "details": "See {IERC1155-safeTransferFrom}."
        },
        "setApprovalForAll(address,bool)": {
            "details": "See {IERC1155-setApprovalForAll}."
        },
        "supportsInterface(bytes4)": {
            "details": "See {IERC165-supportsInterface}."
        },
        "uri(uint256)": {
            "details": "See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\\{id\\}` substring with the actual token type ID."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol:IERC1155 =======
Developer Documentation
{
    "details": "Required interface of an ERC1155 compliant contract, as defined in the https://eips.ethereum.org/EIPS/eip-1155[EIP]. _Available since v3.1._",
    "events": {
        "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."
        },
        "TransferBatch(address,address,address,uint256[],uint256[])": {
            "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
        },
        "TransferSingle(address,address,address,uint256,uint256)": {
            "details": "Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."
        },
        "URI(string,uint256)": {
            "details": "Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."
        }
    },
    "kind": "dev",
    "methods": {
        "balanceOf(address,uint256)": {
            "details": "Returns the amount of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address."
        },
        "balanceOfBatch(address[],uint256[])": {
            "details": "xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length."
        },
        "isApprovedForAll(address,address)": {
            "details": "Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}."
        },
        "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": {
            "details": "xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - `ids` and `amounts` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value."
        },
        "safeTransferFrom(address,address,uint256,uint256,bytes)": {
            "details": "Transfers `amount` tokens of token type `id` from `from` to `to`. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `amount`. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value."
        },
        "setApprovalForAll(address,bool)": {
            "details": "Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller."
        },
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol:IERC1155Receiver =======
Developer Documentation
{
    "details": "_Available since v3.1._",
    "kind": "dev",
    "methods": {
        "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
            "details": "Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. NOTE: To accept the transfer(s), this must return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81, or its own function selector).",
            "params": {
                "data": "Additional data with no specified format",
                "from": "The address which previously owned the token",
                "ids": "An array containing ids of each token being transferred (order and length must match values array)",
                "operator": "The address which initiated the batch transfer (i.e. msg.sender)",
                "values": "An array containing amounts of each token being transferred (order and length must match ids array)"
            },
            "returns": {
                "_0": "`bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed"
            }
        },
        "onERC1155Received(address,address,uint256,uint256,bytes)": {
            "details": "Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. NOTE: To accept the transfer, this must return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61, or its own function selector).",
            "params": {
                "data": "Additional data with no specified format",
                "from": "The address which previously owned the token",
                "id": "The ID of the token being transferred",
                "operator": "The address which initiated the transfer (i.e. msg.sender)",
                "value": "The amount of tokens being transferred"
            },
            "returns": {
                "_0": "`bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed"
            }
        },
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol:IERC1155MetadataURI =======
Developer Documentation
{
    "details": "Interface of the optional ERC1155MetadataExtension interface, as defined in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP]. _Available since v3.1._",
    "events": {
        "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."
        },
        "TransferBatch(address,address,address,uint256[],uint256[])": {
            "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
        },
        "TransferSingle(address,address,address,uint256,uint256)": {
            "details": "Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."
        },
        "URI(string,uint256)": {
            "details": "Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."
        }
    },
    "kind": "dev",
    "methods": {
        "balanceOf(address,uint256)": {
            "details": "Returns the amount of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address."
        },
        "balanceOfBatch(address[],uint256[])": {
            "details": "xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length."
        },
        "isApprovedForAll(address,address)": {
            "details": "Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}."
        },
        "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": {
            "details": "xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - `ids` and `amounts` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value."
        },
        "safeTransferFrom(address,address,uint256,uint256,bytes)": {
            "details": "Transfers `amount` tokens of token type `id` from `from` to `to`. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `amount`. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value."
        },
        "setApprovalForAll(address,bool)": {
            "details": "Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller."
        },
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        },
        "uri(uint256)": {
            "details": "Returns the URI for token type `id`. If the `\\{id\\}` substring is present in the URI, it must be replaced by clients with the actual token type ID."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol:ERC20 =======
Developer Documentation
{
    "details": "Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. The default value of {decimals} is 18. To change this, you should override this function so it returns a different value. We have followed general OpenZeppelin Contracts guidelines: functions revert instead returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",
    "events": {
        "Approval(address,address,uint256)": {
            "details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
        },
        "Transfer(address,address,uint256)": {
            "details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
        }
    },
    "kind": "dev",
    "methods": {
        "allowance(address,address)": {
            "details": "See {IERC20-allowance}."
        },
        "approve(address,uint256)": {
            "details": "See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."
        },
        "balanceOf(address)": {
            "details": "See {IERC20-balanceOf}."
        },
        "constructor": {
            "details": "Sets the values for {name} and {symbol}. All two of these values are immutable: they can only be set once during construction."
        },
        "decimals()": {
            "details": "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."
        },
        "decreaseAllowance(address,uint256)": {
            "details": "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."
        },
        "increaseAllowance(address,uint256)": {
            "details": "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."
        },
        "name()": {
            "details": "Returns the name of the token."
        },
        "symbol()": {
            "details": "Returns the symbol of the token, usually a shorter version of the name."
        },
        "totalSupply()": {
            "details": "See {IERC20-totalSupply}."
        },
        "transfer(address,uint256)": {
            "details": "See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."
        },
        "transferFrom(address,address,uint256)": {
            "details": "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol:IERC20 =======
Developer Documentation
{
    "details": "Interface of the ERC20 standard as defined in the EIP.",
    "events": {
        "Approval(address,address,uint256)": {
            "details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
        },
        "Transfer(address,address,uint256)": {
            "details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
        }
    },
    "kind": "dev",
    "methods": {
        "allowance(address,address)": {
            "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
        },
        "approve(address,uint256)": {
            "details": "Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
        },
        "balanceOf(address)": {
            "details": "Returns the amount of tokens owned by `account`."
        },
        "totalSupply()": {
            "details": "Returns the amount of tokens in existence."
        },
        "transfer(address,uint256)": {
            "details": "Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
        },
        "transferFrom(address,address,uint256)": {
            "details": "Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol:IERC20Metadata =======
Developer Documentation
{
    "details": "Interface for the optional metadata functions from the ERC20 standard. _Available since v4.1._",
    "events": {
        "Approval(address,address,uint256)": {
            "details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
        },
        "Transfer(address,address,uint256)": {
            "details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
        }
    },
    "kind": "dev",
    "methods": {
        "allowance(address,address)": {
            "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
        },
        "approve(address,uint256)": {
            "details": "Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
        },
        "balanceOf(address)": {
            "details": "Returns the amount of tokens owned by `account`."
        },
        "decimals()": {
            "details": "Returns the decimals places of the token."
        },
        "name()": {
            "details": "Returns the name of the token."
        },
        "symbol()": {
            "details": "Returns the symbol of the token."
        },
        "totalSupply()": {
            "details": "Returns the amount of tokens in existence."
        },
        "transfer(address,uint256)": {
            "details": "Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
        },
        "transferFrom(address,address,uint256)": {
            "details": "Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol:ERC721 =======
Developer Documentation
{
    "details": "Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including the Metadata extension, but not including the Enumerable extension, which is available separately as {ERC721Enumerable}.",
    "events": {
        "Approval(address,address,uint256)": {
            "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
        },
        "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
        },
        "Transfer(address,address,uint256)": {
            "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
        }
    },
    "kind": "dev",
    "methods": {
        "approve(address,uint256)": {
            "details": "See {IERC721-approve}."
        },
        "balanceOf(address)": {
            "details": "See {IERC721-balanceOf}."
        },
        "constructor": {
            "details": "Initializes the contract by setting a `name` and a `symbol` to the token collection."
        },
        "getApproved(uint256)": {
            "details": "See {IERC721-getApproved}."
        },
        "isApprovedForAll(address,address)": {
            "details": "See {IERC721-isApprovedForAll}."
        },
        "name()": {
            "details": "See {IERC721Metadata-name}."
        },
        "ownerOf(uint256)": {
            "details": "See {IERC721-ownerOf}."
        },
        "safeTransferFrom(address,address,uint256)": {
            "details": "See {IERC721-safeTransferFrom}."
        },
        "safeTransferFrom(address,address,uint256,bytes)": {
            "details": "See {IERC721-safeTransferFrom}."
        },
        "setApprovalForAll(address,bool)": {
            "details": "See {IERC721-setApprovalForAll}."
        },
        "supportsInterface(bytes4)": {
            "details": "See {IERC165-supportsInterface}."
        },
        "symbol()": {
            "details": "See {IERC721Metadata-symbol}."
        },
        "tokenURI(uint256)": {
            "details": "See {IERC721Metadata-tokenURI}."
        },
        "transferFrom(address,address,uint256)": {
            "details": "See {IERC721-transferFrom}."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol:IERC721 =======
Developer Documentation
{
    "details": "Required interface of an ERC721 compliant contract.",
    "events": {
        "Approval(address,address,uint256)": {
            "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
        },
        "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
        },
        "Transfer(address,address,uint256)": {
            "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
        }
    },
    "kind": "dev",
    "methods": {
        "approve(address,uint256)": {
            "details": "Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."
        },
        "balanceOf(address)": {
            "details": "Returns the number of tokens in ``owner``'s account."
        },
        "getApproved(uint256)": {
            "details": "Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."
        },
        "isApprovedForAll(address,address)": {
            "details": "Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"
        },
        "ownerOf(uint256)": {
            "details": "Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."
        },
        "safeTransferFrom(address,address,uint256)": {
            "details": "Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
        },
        "safeTransferFrom(address,address,uint256,bytes)": {
            "details": "Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
        },
        "setApprovalForAll(address,bool)": {
            "details": "Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."
        },
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        },
        "transferFrom(address,address,uint256)": {
            "details": "Transfers `tokenId` token from `from` to `to`. WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol:IERC721Receiver =======
Developer Documentation
{
    "details": "Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.",
    "kind": "dev",
    "methods": {
        "onERC721Received(address,address,uint256,bytes)": {
            "details": "Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`."
        }
    },
    "title": "ERC721 token receiver interface",
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol:IERC721Metadata =======
Developer Documentation
{
    "details": "See https://eips.ethereum.org/EIPS/eip-721",
    "events": {
        "Approval(address,address,uint256)": {
            "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
        },
        "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
        },
        "Transfer(address,address,uint256)": {
            "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
        }
    },
    "kind": "dev",
    "methods": {
        "approve(address,uint256)": {
            "details": "Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."
        },
        "balanceOf(address)": {
            "details": "Returns the number of tokens in ``owner``'s account."
        },
        "getApproved(uint256)": {
            "details": "Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."
        },
        "isApprovedForAll(address,address)": {
            "details": "Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"
        },
        "name()": {
            "details": "Returns the token collection name."
        },
        "ownerOf(uint256)": {
            "details": "Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."
        },
        "safeTransferFrom(address,address,uint256)": {
            "details": "Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
        },
        "safeTransferFrom(address,address,uint256,bytes)": {
            "details": "Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
        },
        "setApprovalForAll(address,bool)": {
            "details": "Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."
        },
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        },
        "symbol()": {
            "details": "Returns the token collection symbol."
        },
        "tokenURI(uint256)": {
            "details": "Returns the Uniform Resource Identifier (URI) for `tokenId` token."
        },
        "transferFrom(address,address,uint256)": {
            "details": "Transfers `tokenId` token from `from` to `to`. WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."
        }
    },
    "title": "ERC-721 Non-Fungible Token Standard, optional metadata extension",
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/Address.sol:Address =======
Developer Documentation
{
    "details": "Collection of functions related to the address type",
    "kind": "dev",
    "methods": {},
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/Context.sol:Context =======
Developer Documentation
{
    "details": "Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.",
    "kind": "dev",
    "methods": {},
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/Strings.sol:Strings =======
Developer Documentation
{
    "details": "String operations.",
    "kind": "dev",
    "methods": {},
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol:ERC165 =======
Developer Documentation
{
    "details": "Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ``` Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.",
    "kind": "dev",
    "methods": {
        "supportsInterface(bytes4)": {
            "details": "See {IERC165-supportsInterface}."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol:IERC165 =======
Developer Documentation
{
    "details": "Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.",
    "kind": "dev",
    "methods": {
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        }
    },
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/math/Math.sol:Math =======
Developer Documentation
{
    "details": "Standard math utilities missing in the Solidity language.",
    "kind": "dev",
    "methods": {},
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= /home/torof/Desktop/portfolio/marketplace_foundry/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol:SignedMath =======
Developer Documentation
{
    "details": "Standard signed math utilities missing in the Solidity language.",
    "kind": "dev",
    "methods": {},
    "version": 1
}
User Documentation
{
    "kind": "user",
    "methods": {},
    "version": 1
}

======= src/custodial/MarketplaceCustodial.sol:MarketplaceCustodial =======
Developer Documentation
{
    "kind": "dev",
    "methods": {
        "acceptBid(uint256,uint256)": {
            "details": "fees SHOULD be automatically substracted",
            "params": {
                "marketOfferId": "id of the sale Emits a {SaleSuccesful} event"
            }
        },
        "buySale(uint256)": {
            "details": "fees SHOULD be automatically soustracted",
            "params": {
                "marketOfferId": "index of the saleOrder emits a {SaleSuccesful} event"
            }
        },
        "cancelBid(uint256,uint256)": {
            "params": {
                "marketOfferId": "id of the sale Emits a {offerCanceled} event"
            }
        },
        "cancelSale(uint256)": {
            "params": {
                "marketOfferId": "index of the saleOrder"
            }
        },
        "createBid(uint256,uint256,uint256)": {
            "params": {
                "amount": "price of the offer",
                "duration": "duration of the offer emits a {OfferSubmitted} event",
                "marketOfferId": "index of the saleOrder"
            }
        },
        "createSale(address,uint256,uint256)": {
            "params": {
                "contractAddress": "the address of the NFT's contract",
                "price": "price defined by the creator/seller",
                "tokenId": "id of the token within its collection"
            }
        },
        "getSaleOrder(uint256)": {
            "params": {
                "marketOfferId": "id of the sale"
            }
        },
        "modifySale(uint256,uint256)": {
            "params": {
                "marketOfferId": "index of the saleOrder",
                "newPrice": "the new price of the sale"
            }
        },
        "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
            "params": {
                "from": "address the NFT comes from",
                "ids": "an array of all the ids of the tokens within their collection/type",
                "operator": "address allowed to transfer NFTs on owner's behalf",
                "values": "quantity of each received. Use case for Semi Fungible Tokens"
            },
            "returns": {
                "_0": "bytes4  of function {onERC1155BatchReceived} selector"
            }
        },
        "onERC1155Received(address,address,uint256,uint256,bytes)": {
            "params": {
                "from": "address the NFT comes from",
                "id": "the id of the NFT within its collection",
                "operator": "address allowed to transfer NFTs on owner's behalf",
                "value": "quantity received. Use case for Semi Fungible Tokens"
            },
            "returns": {
                "_0": "bytes4  of function {onERC1155Received} selector"
            }
        },
        "onERC721Received(address,address,uint256,bytes)": {
            "params": {
                "from": "address the NFT comes from",
                "operator": "address allowed to transfer NFTs on owner's behalf",
                "tokenId": "id of the NFT within its collection"
            },
            "returns": {
                "_0": "bytes4  function {onERC721Received} selector"
            }
        },
        "owner()": {
            "details": "Returns the address of the current owner."
        },
        "renounceOwnership()": {
            "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
        },
        "setFees(uint256)": {
            "params": {
                "newFees": "the fee the marketplace will receive from each sale"
            }
        },
        "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
        },
        "transferOwnership(address)": {
            "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
        }
    },
    "version": 1
}
User Documentation
{
    "events": {
        "BidCanceled(uint256,address,uint256)": {
            "notice": "Emitted when a bidder cancel its offer"
        },
        "BidModified(uint256,address,uint256)": {
            "notice": "Emitted when a bid is modified"
        },
        "BidSubmitted(uint256,address,uint256)": {
            "notice": "Emitted when a new bid is made"
        },
        "FeesModified(uint256)": {
            "notice": "Emitted when the markeplace fees are modified"
        },
        "NFTReceived(address,address,uint256,uint256,bytes4,bytes)": {
            "notice": "Emitted when a NFT is received"
        },
        "SaleCanceled(uint256)": {
            "notice": "Emitted when a seller cancel its sale"
        },
        "SaleCreated(uint256,address,uint256,address,bytes4,uint256)": {
            "notice": "Emitted when a new market sale is created"
        },
        "SaleModified(uint256,uint256)": {
            "notice": "Emitted when a seller cancel its sale"
        },
        "SaleSuccessful(uint256,address,address,uint256)": {
            "notice": "Emitted when a sale is successfully concluded"
        }
    },
    "kind": "user",
    "methods": {
        "acceptBid(uint256,uint256)": {
            "notice": "a third party made an offer below the asked price and seller accepts"
        },
        "buySale(uint256)": {
            "notice": "allows anyone to buy instantly a NFT at asked price."
        },
        "cancelBid(uint256,uint256)": {
            "notice": "cancel an offer made."
        },
        "cancelSale(uint256)": {
            "notice": "cancel a sale."
        },
        "createBid(uint256,uint256,uint256)": {
            "notice": "make an offer. Offer is made and sent in WETH."
        },
        "createSale(address,uint256,uint256)": {
            "notice": "opens a new sale of a single NFT. Supports {ERC721} and {ERC1155}. Compatible with {ERC721A}"
        },
        "getEthFees()": {
            "notice": "get all fees in ETH collected"
        },
        "getSaleOrder(uint256)": {
            "notice": "get all informations of a sale order by calling its id"
        },
        "getWethFees()": {
            "notice": "get all fees in WETH collected"
        },
        "marketPlaceFee()": {
            "notice": "sale id - all sales ongoing and closed"
        },
        "modifySale(uint256,uint256)": {
            "notice": "modify the sale's price"
        },
        "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
            "notice": "MUST be implemented to be compatible with all ERC1155 standards NFTs batch transfers"
        },
        "onERC1155Received(address,address,uint256,uint256,bytes)": {
            "notice": "MUST be implemented to be compatible with all ERC1155 standards NFTs single transfers"
        },
        "onERC721Received(address,address,uint256,bytes)": {
            "notice": "MUST be implemented to be compatible with all ERC721 standards NFTs"
        },
        "setFees(uint256)": {
            "notice": "set the fees. CANNOT be negative or more than 10%"
        },
        "unlockNFT(address,uint256,address)": {
            "notice": "security function to allow marketplace to send NFT."
        },
        "withdrawEthFees()": {
            "notice": "withdraw all gains in ETH made from the sales fees all at once."
        },
        "withdrawWethFees()": {
            "notice": "withdraw all gains made in WETH from the sales fees all at once."
        }
    },
    "version": 1
}